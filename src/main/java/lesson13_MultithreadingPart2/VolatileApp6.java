package lesson13_MultithreadingPart2;

public class VolatileApp6 {
    // не спасет от условия гонки, а спасет от неправильного чтения.

//    private static boolean isRunning = true;
    private static volatile boolean isRunning = true;// гарантирует что даже в многопоточной среде запись произойдет перед тем как произойдет следующее чтение.

    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(() -> {
            while (isRunning) {
                System.out.println("Still alive");
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        thread.start();

        Thread.sleep(2000);
        isRunning = false;
        //И на этапе компиляции в байт код будет добавлена еще одна строчка, которая впишет systemLock. Который будет ожидать что запись совершится и только потом будет выполнять какие то действия с переменной.
        System.out.println("Stop");

        //Still alive
        //Still alive
        //Still alive
        //Still alive
        //Stop
    }

    /*
    Переменная isRunning может попасть в кеш процессора, в кеш ядра.
    Это означает что есть ядро пк, и в нем 2 ядра - перво и второе.
    И вполне возможно что main будет выполняться во втором потоке, а нами созданный поток будет выполняться в первом ядре.
    Проблема, во первых у каждого процессора есть свой кеш. Кеш - быстрое хранилище, для часто используемых данных.
    Когда мы запускаем этот код в первом ядре будет выставленно true, и во втором true. Дальше когда мы меняем на false во втором потоке - у первого также останется true и он не остановиться.
    Для того чтобы такого не происходило нужно испльзовать ключевое слово volatile.
    Как минимум volatile запрещает кеширование на уровне процессора. Переменная volatile работает дольше, но она позволяет избежать проблем, когда данные кешируются.
    Во вторых очень важная штука состоит в том, что запись в регистр процессора происходит через буфер. Если мы убираем слово volatile и говорим запиши isRunning = false, то запись может произойти в буфер и по факту записи в процессор не произойдет (для того чтобы буфер был записан, нужно вызвать flush()).

    Модель памяти Java называется HappensBefore (происходит перед) - означает что запись произойдет перед тем как произойдет следующее чтение. То есть все операции будут упорядочены.
    Роман елизаров запись лекции Jpoint 2016 года, о том как работет нереализуемость.

     */
}
