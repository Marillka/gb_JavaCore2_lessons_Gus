package lesson13_MultithreadingPart2;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;

public class DemoApp1 {

    public static void main(String[] args) {

//        List<Integer> list = new ArrayList<>();


        /*
        CopyOnWriteArrayList - копирование при записи. Коллекция для множественного чтения и немного записи. Потому что если будет много записи - мы сожрем всю память.
          Потокобезопасная колллекция.
          Чтение выполняется без synchronize.
          Если у нас чтения больше чем записи, то он подходит идеально.
          Что происходит при записи. Он не очень оптимален с точки зрения памяти. Происходит копирование массива и вставка нового элемента в конец. И все потоки, которые читали, они дочитывают старую копию, а все следующие чтения начитаются на новой копии.
          Как только чтений старой копии не остается - она удалится.
          Если поток читал массив и создался новый массив, то он дочитает старый массив.
         */
        List<Integer> list = new CopyOnWriteArrayList<>();


        /*
        Также существуе CopyOnWriteArraySet - тоже самое, только для множества.
         */
//        List<Integer> list2 = new CopyOnWriteArraySet<>();

        /*
        Read write lock-и. Есть набор данных, которые мы читаем. Когда в него кто то пишет - читать нельзя никому. А когда никто не пишет - читать могут сколько угодно.
         */

        /*
        stw - stop the world. В какой то момент времени поток сборщика мусора забирает управление на себя и начинает чистить. В этот момент времени Java приложение простаивает. Это называется ГЦ ПАУЗЫ. Эти паузы незаметны, но они есть. Чем меньше ГЦ паузы - тем стабильнее приложение.
         */

        /*
        Есть старые реализации.
        У ArrayList есть реализация Vector - которая сама по себе полностью синхронизованна.
        У HashMap есть реализация HashTable. Это из Java 5 . Оставлены для обратной совместимости.
         */

        /*
        В утильном классе Collections есть synchronizedList(), который в себя принимает new ArrayList<>().
        Что здесть произойдет?
        Просто ваши обращения в ArrayList обернутся synchronize - ом.
        Не нужно писать synchronized на каждый свой ArrayList - можно исользовать вот это.
        Для сета тоже есть. Потому что они оба реализуют интерфейс Collections.
         */
        List<Integer> list3 = Collections.synchronizedList(new ArrayList<>());


        /*
        С HashMap могут происходить все те же самые спецэффекты, потому что у нас происходит вычисление бакеты, дописывание данных в бакет, проверка существует такая запись или не существует.
        Соответственно в HashMap у нас таже самая проблема.
        HashMap умнее и она проще в реализации чем список, потому что у нее данные разделены. \
        В хешмапе есть в бакеты, и бакетах лежат какие то Entry в виде списка, либо в виде дерева.
        И есть реализация мапы, которая называется ConcurrentHashMap<>().
        Потокобесопасная - это когда я могу писать и читать из разных потоков и не бояться за потерю данных, неправильное чтение, утерю, повреждение и т.д.
        Работает так - делает блокировку на уровне бакета (предоставляет параллельный доступ на уровне бакета). То есть если мы пишем данные в один бакет, а хотим прочитать из другого бакета, понимаем что он не заблокирован и читаем.За счет этого обеспечивается большая пропускная способность. Раньше мы бы блокировали всю коллецию, а сейчас блокируем 1/16.
         */
        Map<String, String> map = new ConcurrentHashMap<>();

    }
}
